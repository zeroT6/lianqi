class KeyboardInputManager {
    constructor() {
        this.events = {},
        window.navigator.msPointerEnabled ? (this.eventTouchstart = "MSPointerDown",
        this.eventTouchmove = "MSPointerMove",
        this.eventTouchend = "MSPointerUp") : (this.eventTouchstart = "touchstart",
        this.eventTouchmove = "touchmove",
        this.eventTouchend = "touchend"),
        this.listen()
    }
    on(a, b) {
        this.events[a] || (this.events[a] = []),
        this.events[a].push(b)
    }
    emit(a, b) {
        const c = this.events[a];
        c && c.forEach(a => {
            a(b)
        }
        )
    }
    listen() {
        const a = this
          , b = {
            38: 0,
            39: 1,
            40: 2,
            37: 3,
            75: 0,
            76: 1,
            74: 2,
            72: 3,
            87: 0,
            68: 1,
            83: 2,
            65: 3
        };
        document.addEventListener("keydown", c => {
            const d = c.altKey || c.ctrlKey || c.metaKey || c.shiftKey
              , e = b[c.which];
            d || e === void 0 || (c.preventDefault(),
            a.emit("move", e)),
            d || 82 !== c.which || a.restart.call(a, c)
        }
        );
        let c, d;
        const e = document.getElementsByClassName("game-container")[0];
        e.addEventListener(this.eventTouchstart, a => {
            !window.navigator.msPointerEnabled && 1 < a.touches.length || 1 < a.targetTouches.length || (window.navigator.msPointerEnabled ? (c = a.pageX,
            d = a.pageY) : (c = a.touches[0].clientX,
            d = a.touches[0].clientY),
            a.preventDefault())
        }
        ),
        e.addEventListener(this.eventTouchmove, a => {
            a.preventDefault()
        }
        ),
        e.addEventListener(this.eventTouchend, b => {
            if (!window.navigator.msPointerEnabled && 0 < b.touches.length || 0 < b.targetTouches.length)
                return;
            let e, f;
            window.navigator.msPointerEnabled ? (e = b.pageX,
            f = b.pageY) : (e = b.changedTouches[0].clientX,
            f = b.changedTouches[0].clientY);
            const g = e - c
              , h = Math.abs(g)
              , i = f - d
              , j = Math.abs(i);
            10 < Math.max(h, j) && a.emit("move", h > j ? 0 < g ? 1 : 3 : 0 < i ? 2 : 0)
        }
        )
    }
    restart(a) {
        a.preventDefault(),
        this.emit("restart")
    }
    keepPlaying(a) {
        a.preventDefault(),
        this.emit("keepPlaying")
    }
    bindButtonPress(a, b) {
        const c = document.querySelector(a);
        c.addEventListener("click", b.bind(this)),
        c.addEventListener(this.eventTouchend, b.bind(this))
    }
  }
  class HTMLActuator {
    constructor() {
        this.tileContainer = document.querySelector(".tile-container"),
        this.scoreContainer = document.querySelector(".score-container"),
        this.bestContainer = document.querySelector(".best-container"),
        this.messageContainer = document.querySelector(".game-message"),
        this.score = 0
    }
    actuate({cells: a}, b) {
        const c = this;
        window.requestAnimationFrame( () => {
            c.clearContainer(c.tileContainer),
            a.forEach(a => {
                a.forEach(a => {
                    a && c.addTile(a)
                }
                )
            }
            ),
            b.terminated && (b.over ? c.message(!1) : b.won && c.message(!0))
        }
        )
    }
    continueGame() {
        this.clearMessage()
    }
    clearContainer(a) {
        for (; a.firstChild; )
            a.removeChild(a.firstChild)
    }
    addTile(a) {
        const b = this
          , c = document.createElement("div")
          , d = document.createElement("div")
          , e = a.previousPosition || {
            x: a.x,
            y: a.y
        }
          , f = this.positionClass(e)
          , g = ["tile", `tile-${a.value}`, f];
        2048 < a.value && g.push("tile-super"),
        this.applyClasses(c, g),
        d.classList.add("tile-inner"),
        d.textContent = a.value,
        a.previousPosition ? window.requestAnimationFrame( () => {
            g[2] = b.positionClass({
                x: a.x,
                y: a.y
            }),
            b.applyClasses(c, g)
        }
        ) : a.mergedFrom ? (g.push("tile-merged"),
        this.applyClasses(c, g),
        a.mergedFrom.forEach(a => {
            b.addTile(a)
        }
        )) : (g.push("tile-new"),
        this.applyClasses(c, g)),
        c.appendChild(d),
        this.tileContainer.appendChild(c)
    }
    applyClasses(a, b) {
        a.setAttribute("class", b.join(" "))
    }
    normalizePosition({x: a, y: b}) {
        return {
            x: a + 1,
            y: b + 1
        }
    }
    positionClass(a) {
        return a = this.normalizePosition(a),
        `tile-position-${a.x}-${a.y}`
    }
    updateScore(a) {
        this.clearContainer(this.scoreContainer);
        const b = a - this.score;
        if (this.score = a,
        this.scoreContainer.textContent = this.score,
        0 < b) {
            const a = document.createElement("div");
            a.classList.add("score-addition"),
            a.textContent = `+${b}`,
            this.scoreContainer.appendChild(a)
        }
    }
    updateBestScore(a) {
        this.bestContainer.textContent = a
    }
    message(a) {
        const b = a ? "game-won" : "game-over"
          , c = a ? "You win!" : "Game over!";
        this.messageContainer.classList.add(b),
        this.messageContainer.getElementsByTagName("p")[0].textContent = c
    }
    clearMessage() {
        this.messageContainer.classList.remove("game-won"),
        this.messageContainer.classList.remove("game-over")
    }
  }
  class Grid {
    constructor(a, b) {
        this.size = a,
        this.cells = b ? this.fromState(b) : this.empty()
    }
    empty() {
        const a = [];
        for (let b = 0; b < this.size; b += 1) {
            const c = a[b] = [];
            for (let a = 0; a < this.size; a += 1)
                c.push(null)
        }
        return a
    }
    fromState(a) {
        const b = [];
        for (let c = 0; c < this.size; c += 1) {
            const d = b[c] = [];
            for (let b = 0; b < this.size; b += 1) {
                const e = a[c][b];
                d.push(e ? new Tile(e.position,e.value) : null)
            }
        }
        return b
    }
    randomAvailableCell() {
        const a = this.availableCells();
        if (a.length)
            return a[Math.floor(Math.random() * a.length)]
    }
    availableCells() {
        const a = [];
        return this.eachCell( (b, c, d) => {
            d || a.push({
                x: b,
                y: c
            })
        }
        ),
        a
    }
    eachCell(a) {
        for (let b = 0; b < this.size; b += 1)
            for (let c = 0; c < this.size; c += 1)
                a(b, c, this.cells[b][c])
    }
    cellsAvailable() {
        return !!this.availableCells().length
    }
    cellAvailable(a) {
        return !this.cellOccupied(a)
    }
    cellOccupied(a) {
        return !!this.cellContent(a)
    }
    cellContent(a) {
        return this.withinBounds(a) ? this.cells[a.x][a.y] : null
    }
    insertTile(a) {
        this.cells[a.x][a.y] = a
    }
    removeTile({x: a, y: b}) {
        this.cells[a][b] = null
    }
    withinBounds({x: a, y: b}) {
        return 0 <= a && a < this.size && 0 <= b && b < this.size
    }
    serialize() {
        const a = [];
        for (let b = 0; b < this.size; b += 1) {
            const c = a[b] = [];
            for (let a = 0; a < this.size; a += 1)
                c.push(this.cells[b][a] ? this.cells[b][a].serialize() : null)
        }
        return {
            size: this.size,
            cells: a
        }
    }
  }
  class Tile {
    constructor({x: a, y: b}, c) {
        this.x = a,
        this.y = b,
        this.value = c || 2,
        this.previousPosition = null,
        this.mergedFrom = null
    }
    savePosition() {
        this.previousPosition = {
            x: this.x,
            y: this.y
        }
    }
    updatePosition({x: a, y: b}) {
        this.x = a,
        this.y = b
    }
    serialize() {
        return {
            position: {
                x: this.x,
                y: this.y
            },
            value: this.value
        }
    }
  }
  window.fakeStorage = {
    _data: {},
    setItem(a, b) {
        return this._data[a] = b + ""
    },
    getItem(a) {
        return this._data.hasOwnProperty(a) ? this._data[a] : void 0
    },
    removeItem(a) {
        return delete this._data[a]
    },
    clear() {
        return this._data = {}
    }
  };
  class LocalStorageManager {
    constructor() {
        this.bestScoreKey = "bestScore",
        this.gameStateKey = "gameState";
        const a = this.localStorageSupported();
        this.storage = a ? window.localStorage : window.fakeStorage
    }
    localStorageSupported() {
        const a = "test";
        try {
            const b = window.localStorage;
            return b.setItem(a, "1"),
            b.removeItem(a),
            !0
        } catch (a) {
            return !1
        }
    }
    getBestScore() {
        return this.storage.getItem(this.bestScoreKey) || 0
    }
    setBestScore(a) {
        this.storage.setItem(this.bestScoreKey, a)
    }
    getGameState() {
        const a = this.storage.getItem(this.gameStateKey);
        return a ? JSON.parse(a) : null
    }
    setGameState(a) {
        this.storage.setItem(this.gameStateKey, JSON.stringify(a))
    }
    clearGameState() {
        this.storage.removeItem(this.gameStateKey)
    }
  }
  export class GameManager {
    constructor(a) {
        this.size = a,
        this.inputManager = new KeyboardInputManager,
        this.storageManager = new LocalStorageManager,
        this.actuator = new HTMLActuator,
        this.startTiles = 2,
        this.inputManager.on("move", this.move.bind(this)),
        this.inputManager.on("restart", this.restart.bind(this)),
        this.inputManager.on("keepPlaying", this.keepPlaying.bind(this)),
        this.setup()
    }
    restart() {
        this.storageManager.clearGameState(),
        this.actuator.continueGame(),
        this.setup()
    }
    keepPlaying() {
        this.keepPlaying = !0,
        this.actuator.continueGame()
    }
    isGameTerminated() {
        return this.over || this.won && !this.keepPlaying
    }
    setup() {
        const a = this.storageManager.getGameState();
        a ? (this.grid = new Grid(a.grid.size,a.grid.cells),
        this.score = a.score,
        this.over = a.over,
        this.won = a.won,
        this.keepPlaying = a.keepPlaying) : (this.grid = new Grid(this.size),
        this.score = 0,
        this.over = !1,
        this.won = !1,
        this.keepPlaying = !1,
        this.addStartTiles()),
        this.actuate()
    }
    addStartTiles() {
        for (let a = 0; a < this.startTiles; a += 1)
            this.addRandomTile()
    }
    addRandomTile() {
        if (this.grid.cellsAvailable()) {
            const a = .9 > Math.random() ? 2 : 4
              , b = new Tile(this.grid.randomAvailableCell(),a);
            this.grid.insertTile(b)
        }
    }
    actuate() {
        this.storageManager.getBestScore() < this.score && this.storageManager.setBestScore(this.score),
        this.over ? this.storageManager.clearGameState() : this.storageManager.setGameState(this.serialize()),
        this.actuator.actuate(this.grid, {
            score: this.score,
            over: this.over,
            won: this.won,
            bestScore: this.storageManager.getBestScore(),
            terminated: this.isGameTerminated()
        })
    }
    serialize() {
        return {
            grid: this.grid.serialize(),
            score: this.score,
            over: this.over,
            won: this.won,
            keepPlaying: this.keepPlaying
        }
    }
    prepareTiles() {
        this.grid.eachCell( (a, b, c) => {
            c && (c.mergedFrom = null,
            c.savePosition())
        }
        )
    }
    moveTile(a, b) {
        this.grid.cells[a.x][a.y] = null,
        this.grid.cells[b.x][b.y] = a,
        a.updatePosition(b)
    }
    move(a) {
        const b = this;
        if (this.isGameTerminated())
            return;
        let c, d;
        const e = this.getVector(a)
          , f = this.buildTraversals(e);
        let g = !1;
        this.prepareTiles(),
        f.x.forEach(a => {
            f.y.forEach(f => {
                if (c = {
                    x: a,
                    y: f
                },
                d = b.grid.cellContent(c),
                d) {
                    const a = b.findFarthestPosition(c, e)
                      , f = b.grid.cellContent(a.next);
                    if (f && f.value === d.value && !f.mergedFrom) {
                        const c = new Tile(a.next,2 * d.value);
                        c.mergedFrom = [d, f],
                        b.grid.insertTile(c),
                        b.grid.removeTile(d),
                        d.updatePosition(a.next),
                        b.score += c.value,
                        65536 === c.value && (b.won = !0)
                    } else
                        b.moveTile(d, a.farthest);
                    b.positionsEqual(c, d) || (g = !0)
                }
            }
            )
        }
        ),
        g && (!this.movesAvailable() && (this.over = !0),
        this.actuate())
    }
    getVector(a) {
        return {
            0: {
                x: 0,
                y: -1
            },
            1: {
                x: 1,
                y: 0
            },
            2: {
                x: 0,
                y: 1
            },
            3: {
                x: -1,
                y: 0
            }
        }[a]
    }
    buildTraversals({x: a, y: b}) {
        const c = {
            x: [],
            y: []
        };
        for (let d = 0; d < this.size; d += 1)
            c.x.push(d),
            c.y.push(d);
        return 1 === a && (c.x = c.x.reverse()),
        1 === b && (c.y = c.y.reverse()),
        c
    }
    findFarthestPosition(a, {x: b, y: c}) {
        let d;
        do
            d = a,
            a = {
                x: d.x + b,
                y: d.y + c
            };
        while (this.grid.withinBounds(a) && this.grid.cellAvailable(a));
        return {
            farthest: d,
            next: a
        }
    }
    movesAvailable() {
        return this.grid.cellsAvailable() || this.tileMatchesAvailable()
    }
    tileMatchesAvailable() {
        const a = this;
        let b;
        for (let c = 0; c < this.size; c += 1)
            for (let d = 0; d < this.size; d += 1)
                if (b = this.grid.cellContent({
                    x: c,
                    y: d
                }),
                b)
                    for (let e = 0; 4 > e; e += 1) {
                        const f = a.getVector(e)
                          , g = {
                            x: c + f.x,
                            y: d + f.y
                        }
                          , h = a.grid.cellContent(g);
                        if (h && h.value === b.value)
                            return !0
                    }
        return !1
    }
    positionsEqual(a, b) {
        return a.x === b.x && a.y === b.y
    }
  }
  